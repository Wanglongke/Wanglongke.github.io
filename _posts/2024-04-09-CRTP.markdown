---
layout: post
title:  奇异递归模式-CRTP
date:   2024-04-09 15:30:00 +0300
tags:   设计模式
description:  cpp奇异递归模式
---

# [基本说明](#基本说明)

奇异递归模式(Curiously Recurring Template Pattern, CRTP), 是cpp模板编程时的一种模板使用方式，即把派生类作为基类的模板参数。更一般的称作F-bound polymorphism，这出自于1989年的这篇论文，“F-bounded polymorphism for object-oriented programming”.

## [什么是CRTP](#什么是CRTP)
CRTP将派生类作为基类的模板参数，允许重写基类的方法，从而实现多态。它多态的实现发生在编译器，因此称为静态多态。   
CRTP的实现通常如下：   
```cpp
template<typename Derived> 
class Base{
    ...
    void f(){
        static_cast<Derived*>(this)->f();
    }
};

class Derived: public Base<Derived>{
    ...
    void f(){

    }
};
```

## [CRTP的优缺点](#CRTP的优缺点)
CRTP通过继承实现了**静态**多态，相对于使用虚函数的多态，其性能更好。通过测试虚函数的调用耗时大约是非虚的静态多态的9~10倍
## [CRTP的诸多细节](#CRTP的诸多细节)

### [禁止套娃](#禁止套娃)

示例1：
```cpp
template<typename C>
struct B
{
    typedef typename C::value_type value_type;
    value_type* p_;
};


struct D : B<D>
{
    using value_type = float;
};

int main()
{
    D d{};
    return 0;
}

```
上述代码编译会失败(MSVC)
```
C2039  "value_type": 不是"D"的成员
C3646  "value_type": 未知重写说明符
C4430  "..."
```

示例2：
```cpp
template<typename D> 
class B
{
public:
    ...
    void f(){
        static_cast<D*>(this)->f();
    }
};

class D: public B<D>{
    // 派生类没有f的实现
};
```
上述代码编译期不会失败，也不会产生警告，错误发生在运行期，错误如下：
```cpp
Stack overflow 
```
也有人会出现以下错误：
```cpp
Process finished with exit code 139 (interruoted by signal 11: SIGSEGV)
```

### [析构](#析构)

如下错误示例：
```cpp
B<D> *b = new D;
...
delete b;
```
上述代码无法调用D类的析构，可以编译通过，运行不报错，会造成D类无法析构，内存泄漏。

```cpp
template<typename D>
class B
{
public:

    B() {
        std::cout << "B call construction" << std::endl;
    }

    ~B() {
        std::cout << "B call deconstruction" << std::endl;
    }

    void f() {
        std::cout << "B call function f" << std::endl;
        static_cast<D*>(this)->f();
    }
};

class D : public B<D> {

public:

    D() {
        std::cout << "D call construction" << std::endl;
    }

    ~D() {
        std::cout << "D call deconstruction" << std::endl;
    }

    void f() {
        std::cout << "D call function f" << std::endl;
    }
};


int main(int argc, char* argv[])
{
    B<D>* b = new D;
    b->f();
    delete b;
    return 0;
}
```

其运行结果如下：
```cpp
B call construction
D call construction
B call function f
D call function f
B call deconstruction
```
解决方法如下：   
1. 写一个函数负责析构
```cpp
template<typename D>
void Destroy(B<D>* b){
    delete static_cast<D*>(b);
}
```
2. 使用虚析构函数

### [权限](#权限)

CRTP

